rules = [
  DisableSyntax,
  Disable,
  LeakingImplicitClassVal,
  NoValInForComprehension,
  ProcedureSyntax,
  RedundantSyntax,
  ExplicitResultTypes,
  TypelevelUnusedIO,
  TypelevelMapSequence,
  TypelevelAs,
  TypelevelUnusedShowInterpolator,
  TypelevelIORandomUUID
]
triggered.rules = [
  DisableSyntax,
  Disable,
  LeakingImplicitClassVal,
  NoValInForComprehension,
  ProcedureSyntax,
  RedundantSyntax,
]

DisableSyntax.noVars = true
DisableSyntax.noThrows = true
DisableSyntax.noNulls = true
DisableSyntax.noReturns = true
DisableSyntax.noWhileLoops = true
DisableSyntax.noAsInstanceOf = true
DisableSyntax.noIsInstanceOf = true
DisableSyntax.noXml = true
DisableSyntax.noDefaultArgs = false
DisableSyntax.noFinalVal = true
DisableSyntax.noFinalize = true
DisableSyntax.noValPatterns = true
DisableSyntax.noSemicolons = true
DisableSyntax.noValInAbstract = true
DisableSyntax.noImplicitObject = true
DisableSyntax.keywords = [
  this,
  do,
  super,
  try,
  catch,
  abstract
]

ExplicitResultTypes.memberVisibility = [
  Public,
  Protected,
  Private
]
ExplicitResultTypes.fatalWarnings = true

Disable.symbols = [
  {
    symbol = "scala.Option.get"
    id = "Option.get"
    message =
      """|Option.get is the root of all evils
         |
         |If you want Option.get, you should use match case Some/None"""
  }
  {
    symbol = "scala.collection.IterableOps.head"
    id = "iterable.head"
    message = "Instead of head use headOption or match case head :: tail => ???"
  }
  {
    symbol = "scala.collection.IterableOps.last"
    id = "iterable.last"
    message = "Instead of last use lastOption"
  }
  {
    symbol = "scala.collection.immutable.List.last"
    id = "List.last"
    message = "Instead of List.last use List.lastOption"
  }
  {
    symbol = "scala.collection.mutable"
    id = "collection.mutable"
    message = "Instead of collection.mutable use collection.immutable"
  }
  "java.lang.System"
  "scala.Predef.assert"
  "scala.Predef.assume"
  "scala.Predef.require"
]
