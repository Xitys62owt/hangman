# Виселица

## Обратите внимание, что вам доступно 2 репозитория с ДЗ:

- **upstream** https://gitlab.education.tbank.ru/backend-academy-scala-2025/homeworks/hw1-hangman
- **fork** `https://gitlab.education.tbank.ru/backend-academy-scala-2025/homeworks-forks/<student>/hw1-hangman`

В **upstream** репозитории находится исходный код ДЗ, а так же вы можете открыть issue или MR с исправлением условий ДЗ,
если заметите ошибку (MR с исправлением нужно открывать из fork в upstream).
**fork** репозиторий индивидуален для каждого студента (у вас есть доступ только до своего репозитория, форки других
студентов вы не видите). В fork репозитории вы выполняете своё домашнее задание.

--- 

## Задание

Разработайте консольную версию игры "Виселица", в которой игрок пытается угадать загаданное слово, вводя буквы по одной
за раз. Слово выбирается по уровню сложности и категории, случайно, из предварительно заданного списка слов. Количество
попыток ограничено, и за каждую неверную догадку визуализируется часть виселицы и фигурки висельника.

## Функциональные требования

### Не интерактивный (тестовый) режим работы

* Программа должна иметь возможность запуска в не интерактивном (без взаимодействия с пользователем) режиме.
* В не интерактивном режиме программа должна принимать два аргумента командной строки: "загаданное" слово и "буквы для
  угадывания".
* Не интерактивный режим автоматически активируется при вызове программы **с двумя аргументами командной строки**.
* От программы ожидается вывод в формате "угаданные_буквы_слова;результат".
  Не угаданные буквы должны быть заменены символом звёздочки `*`. Подробнее - [см. пример](doc/test-example.md).

### Интерактивный (пользовательский) режим работы

* Интерактивный режим автоматически активируется при вызове программы без аргументов командной строки.
* Программа должна выбрать случайную категорию (список) слов, если этого не сделал пользователь.
* Программа должна выбрать случайный уровень сложности, если этого не сделал пользователь.
* Программа должна выбирать случайное слово из выбранной категории (списка).
* Игрок вводит одну букву за раз, чтобы угадать слово.
* Экран должен обновляться после каждого ввода, показывая уже угаданные буквы и прочерки на местах неуказанных букв.
* Визуализация виселицы должна добавляться постепенно с каждой неправильной попыткой.
* Игра завершается, когда слово угадано полностью или когда висельник полностью нарисован.
* Количество попыток ограничено и должно быть указано в начале игры.

## Нефункциональные требования

* Код должен быть написан ясно и структурировано в соответствии с требованиями,
  указанными в разделе "Требования к ДЗ" информационного блока.
* Программа должна иметь текстовый интерфейс.

## Описание входных и выходных данных

**INFO**: Приводимая ниже информация относится к интерактивному режиму работы программы.

### Ввод

* Ввод буквы осуществляется через стандартную консоль ввода.
* Ввод не должен быть чувствительным к регистру.

### Вывод

* На каждом этапе игры должно отображаться текущее состояние угадываемого слова и виселицы.
* При успешном угадывании буквы нужно обновить состояние слова на экране.
* При неправильной букве нужно обновить изображение виселицы и указать кол-во оставшихся попыток.

---

## "Инструкции" по реализации

* Рекомендуется реализовать программу в виде "движка", содержащего логику игры, и интерфейсов для интерактивного и
  тестового режимов работы.
* Создайте словарь, содержащий список слов для загадывания.
* Реализуйте систему для случайного выбора слова из словаря в начале каждой игры.
* Средства для получения ввода пользователя и вывода состояния игры.
* Логику определения правильности угаданной буквы.
* Логику визуализации виселицы при каждой ошибке.
* Учтите факт сложности игры: не забудьте сделать настраиваемым количество допустимых ошибок, и чтобы эту настройку
  можно было легко изменять или сделать настройку зависимой от сложности слова.
* При реализации вам могут пригодиться следующие примитивы:
    * Словарь: получение случайного слова.
    * Игровая сессия: хранения ответа, текущего состояния ответа пользователя, максимального числа попыток и числа
      произведенных попыток.
    * Результат угадывания (ADT): текущее состояние, количество сделанных попыток, максимальное количеству попыток и
      сообщение для пользователя.

## Тестирование

* Напишите тесты для проверки правильности выбора слова из списка.
* Проверьте корректность отображения состояния игры после каждого ввода пользователя.
* Убедитесь, что введенные буквы корректно обрабатываются вне зависимости от их регистра.
* Игра не запускается, если загадываемое слово имеет некорректную длину.
* После превышения заданного количества попыток игра всегда возвращает поражение.
* Состояние игры корректно изменяется при угадывании/не угадывании.
* Проверка, что при отгадывании ввод строки длиной больше чем 1 (опечатка) приводит к повторному вводу, без изменения
  состояния.

## Ограничения и советы

### Советы

* Не пытайтесь делать всё в одной функции/классе, подумайте как вы разделите код и будете его тестировать.
* Разделите логику игры и интерфейс на отдельные модули.
* Поделите логику на части и начните разработку с какой-то из них, например, выбора случайного слова или машины
  состояния игры.
* Тестируйте каждую часть приложения по мере ее реализации.
* Попробуйте представить, что будет если вызвать 2 или более экземпляра игры, подумайте над понятием игровой
  сессии
* Используйте доменные ошибки

### Ограничения логики

* В игре должен быть использован стандартный текстовый ввод/вывод.
* Не использовать внешние библиотеки для управления состоянием игры и ввода/вывода.

### Ограничения по code style

Ниже приведены ограничения, которые **вы должны соблюдать при написании ДЗ**. Часть правил реализована автоматически за
счёт линтеров кода, но мы могли что-то не предусмотреть, и если вы успешно сдадите ДЗ, при этом, нарушив, правила, то
**можем вам снизить баллы за ДЗ**.

* Переменные и функции должны иметь осмысленные названия;
* Использовать java коллекции запрещается (используйте `Scala` коллекции);
* Использовать scala `mutable` коллекции запрещается (используйте `immutable` коллекции);
* Использовать `var` запрещается (используйте `val`);
* Использование `this` запрещается (используйте `self`, если надо);
* Использование `throw` запрещается (используйте `Either`/`Option`, если надо работать с ошибкой);
* Использование `null` запрещается (используйте `Option`);
* Использование `return` запрещается;
* Использование `System.exit` запрещается;
* Касты или проверки на типы с помощью методов из Java вроде `asInstanceOf` запрещаются;
* Использование циклов запрещается (используйте `for comprehension`, `tailRec`, или методы коллекций `fold`/`foldLeft`/
  `reduce`/ `map`/ `filter`);
* Использование `foreach` (аналогично предыдущему пункту);
* Использование небезопасных вызовов разрешено только в тестах (например `.get` у `Option`);
* Использование `require` / `assert` для ошибок запрещается (используйте `shouldBe` из scalatest и его вариации);
* Использование аннотаций запрещается (кроме `@tailrec`).

## Структура проекта

```text
├── project
│   ├── build.properties    - версия sbt
│   └── plugins.sbt         - плагины для sbt
├── src
│   ├── main
│   │   └── scala
│   │      └── tbank.academy.scala.hangman
│   └── test
│       └── scala
│          └── tbank.academy.scala.hangman
...
├── .gitlab-ci.yml  - конфигурация пайплайна
├── .sbtopts        - опции jvm для sbt
├── .scalafix.conf  - конфигурация линтеров
├── .scalafmt.conf  - конфигурация форматирования кода
├── build.sbt       - конфигурация проекта
└── README.md       - Условия ДЗ
```

## Дополнительные материалы

* https://en.wikipedia.org/wiki/Hangman_(game)
* https://habr.com/ru/companies/lanit/articles/660895/
* https://github.com/topics/terminal-game

---

# Организационные моменты

## Сроки и процедура сдачи ДЗ

На реализацию проекта отводится весь модуль. По завершению модуля ассистент имеет полное право выставить **0 баллов** за
работу, если она не была предоставлена в срок.

Доработка ДЗ по замечаниям возможна до дедлайна. Доработка ДЗ после дедлайна согласуется с ассистентом, после доработки
количество баллов может быть увеличено.

В ответ на задание нужно прислать кликабельную ссылку на репозиторий.
Больше подробностей по сдаче ДЗ можно найти в разделе "Информационный блок".

При создании `Merge request` для сдачи ДЗ на проверку -
воспользуйся [шаблоном](.gitlab/merge_request_templates/requirements.md) для заполнения описания
MR: [как применить шаблон](doc/mr-template.png).

## Критерии оценки

За базовое задание можно получить максимум 100 баллов.

* `+15` бонусных баллов за реализацию механизма подсказки, например, для слова "бабушка" подсказкой может быть "близкий
  родственник".
* `+15` бонусных баллов - за участие в рецензировании проектов других студентов в качестве рецензента (имеется ввиду
  выполнение ревью ДЗ другого студента; для получения доступа к ревью другого студента обращайтесь к ассистенту).
* Дополнительно можно получить личные бонусные баллы на усмотрение ассистента курса.

Детали о снятии обычных и начислении бонусных баллов можно найти
в разделе "Информационный блок" (
см. [1.7 Баллы и оценка за курс](https://my.tbank.ru/edu/educate/course/9f925592-6abb-40a2-ba59-70fe229094aa/unit/c4c883bd-fdf5-4165-9762-b19dc7bc6770)).
